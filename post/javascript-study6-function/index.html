<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>자바스크립트 제대로 배우기 - 7. 함수 표현식 |  Luis' Webscience</title>
    <meta name="description" content="Web, JavaScript에 관한 이야기">
    <meta name="author" content="Luis Park">
    <meta name="keywords" content="" />
    <meta name="generator" content="haroopress v0.9.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/rss.xml" rel="alternate" title="Luis' Webscience" type="application/rss+xml">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Rokkitt:400,700' rel='stylesheet' type='text/css'>

    <!-- Le styles -->
    <link rel="canonical" href="">

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="/css/font-awesome.css" rel="stylesheet">
    <link href="/css/markdown.css" rel="stylesheet">
    <link href="/css/haroopress.css" rel="stylesheet">
    <link href="/css/theme.css" rel="stylesheet">
    <link href="/css/code/default.css" rel="stylesheet">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon-64.png">

    <!-- Le javascript -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/jquery.jsonp.js"></script>
    <script src="/js/mustache.js"></script>
    <script src="/js/apps/github.js"></script>
    <script src="/js/apps/twitter.js"></script>
</head>
<body data-spy="scroll" data-target=".subnav" data-offset="50">

    <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </a>
            <div class="social">
                
                <a class="rss" href="/rss.xml">RSS</a>
            </div>
            

            <div class="nav-collapse">
                <ul class="nav">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/archives">Archives</a>
                    </li>
                    
                </ul>
            </div>
            <form action="/search" id="search">
                <input type="text" value="" placeholder="Search" name="q" id="search-text" class="placeholder">
            </form>
        </div>
    </div>
</div>

    <div class="container">
    <div class="row">
        <div class="span3 side">
            <div id="author" class="well">
                <h3 class="title">About Author</h3>
                 <div class="gravatar">
                    <img src="http://www.gravatar.com/avatar/4400fbdafe7989d1e078275ef66f27f2?r=pg&amp;s=128.jpg&amp;d=identicon" />
                </div>
                <ul class="profile">
                    <li class="nickname">Luis Park</li>
                    <li class="blog"><a href="luispigu.github.com" target="_blank">luispigu.github.com</a></li>
                    <li class="twitter"><a href="http://twitter.com/luispigu" target="_blank">@luispigu</a></li>
                    <li class="github"><a href="https://github.com/luispigu" target="_blank"></li>
                </ul>
     
                <p>
                    <a href="https://twitter.com/luispigu" class="twitter-follow-button" data-show-count="true">Follow @luispigu</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                </p>
                
            </div>
            <div class="well recent">
    <h6 class="title">Recent Articles</h6>
    <ul class="nav nav-list">
    
        <li>
            <a href="/post/javascript-study0-Start" target="_blank">자바스크립트 제대로 배우기 - 0. 준비</a>

        </li>
    
        <li>
            <a href="/post/javascript-study1-Introduction-and-html-javascript" target="_blank">자바스크립트 제대로 배우기 - 1. 자바스크립트란 무엇인가, 2. HTML 속의 자바스크립트</a>

        </li>
    
        <li>
            <a href="/post/javascript-study2-day-basic-language" target="_blank">자바스크립트 제대로 배우기 - 3.언어의 기초</a>

        </li>
    
        <li>
            <a href="/post/javascript-study3-variable-and-scope-memory" target="_blank">자바스크립트 제대로 배우기 - 4.변수와 스코프, 메모리</a>

        </li>
    
        <li>
            <a href="/post/javascript-study4-understanding-oop" target="_blank">자바스크립트 제대로 배우기 - 6.1 객체에 대한 이해</a>

        </li>
    
        <li>
            <a href="/post/javascript-study5-reference-type" target="_blank">자바스크립트 제대로 배우기 - 5.참조 타입</a>

        </li>
    
        <li>
            <a href="/post/javascript-study6-function" target="_blank">자바스크립트 제대로 배우기 - 7. 함수 표현식</a>

        </li>
    
    </ul>
</div>
            			<div class="well category">
                <ul class="nav nav-list">
                    <li class="nav-header title">Categories</li>
                    <li class="active"><a href="/category">Home</a></li>
                    
                </ul>
            </div>
        </div>
        <div class="span9 articles">
            <div class="row">
                <div class="span9">
                    <div class="well">
                        
                        <div class="page-header">
                            <p class="meta">
                                Javascript <!-- 임시 카테고리 -->
                                <span class="time">Sunday, May 18 2014 11:22 PM</span>
                            </p>
                            <h1>자바스크립트 제대로 배우기 - 7. 함수 표현식</h1>
                        </div>

                        <div class="pull-right social-area">
                            
                            

                            
                        </div>

                        <div class="markdown-wrapper">
                            <h1 id="toc_84">자바스크립트 제대로 배우기6 - 7. 함수 표현식</h1>
<p><em class="label "><strong>이 포스팅은 페이스북 자바스크립트 제대로 배우기 그룹의 공부 내용을 요약한 것입니다.</strong></em><br>
출처 : &lt;&lt;프론트엔드 개발자를 위한 자바스크립트&gt;&gt;(2013 인사이트, 한선용 옮김)</p>
<h3 id="toc_85">7장 함수 표현식</h3>

<ul>
<li>함수를 정의하는 방법은 <code>함수 선언</code>, <code>함수 표현식</code> 두 가지 방법</li>
<li>파이어폭스, 크롬, 사파리, 오페라는 모두 함수에 비표준 프로퍼티 named을 지원

<ul>
<li>functionName.name 으로 함수의 이름을 가져올 수 있음</li>
</ul></li>
<li>함수 호이스팅(hoisting)

<ul>
<li>함수 선언의 특징</li>
<li>함수 선언부를 다른 코드보다 먼저 읽고 실행함</li>
</ul></li>
<li>함수 표현식의 가장 많이 쓰이는 형태는

<ul>
<li><code>javascript var functionName = function(args){..};</code></li>
<li>이렇게 생성된 함수는 function 키워드 다음에 함수의 이름이 없으므로 <code>익명 함수</code>로 가정</li>
<li>때때로 익명 함수를 람다(lamda)함수라고 부르기도 함</li>
<li>이 함수의 name 프로퍼티는 빈 문자열</li>
</ul></li>
<li>함수 선언과 함수 표현식 방법의 차이

<ul>
<li>자바스크립트에는 함수 오버로딩이 없기 때문에 같은 함수를 조건에 따라 여러개 만들지 못함</li>
<li>함수 선언으로는 같은 함수를 여러 번 선언 시 마지막 함수가 보통 사용됨</li>
<li>함수 표현식을 이용하면 조건식에 따라 변수에 각각 다른 함수 표현식을 할당하는 방법으로 사용 가능
<code>javascript
varhello;
if(condition){
    hello = function(){
        console.log(&quot;Hi!&quot;);
    };
}else{
    hello = function(){
        console.log(&quot;Man~&quot;);
    };
}
</code></li>
</ul></li>
<li>5장에서 createComparisonFunction()과 같은 방법으로 사용가능</li>
<li>값처럼 쓰이는 함수를 함수 표현식이라 부름</li>
</ul>

<h4 id="toc_86">7.1 재귀</h4>

<ul>
<li>함수가 자기 자신을 이름으로 호출하는 형태</li>
<li>재귀 호출 시 자신의 이름을 쓰지 않고 <code>arguments.callee</code>를 쓰면 함수를 다른 변수에 할당해도 정확히 동작함</li>
<li>재귀 함수를 사용할 때는 항상 함수 이름 대신 <code>arguments.callee</code>를 쓰기를 권함</li>
<li>스트릭트 모드에서는 arguments.callee접근 불가능</li>
<li>이때는 예를 들어, 이름 붙은 함수 표현식 f()를 생성해 변수 factorial에 할당하면 스트릭트와 비스트릭트 모드에서 잘 동작</li>
</ul>

<h4 id="toc_87">7.2 클로저</h4>

<ul>
<li>익명함수와 클로저는 자주 <code>잘못</code> 혼용됨</li>
<li><code>클로저</code>란 다른 함수의 스코프에 있는 변수에 접근 가능한 함수</li>
<li>함수를 처음 호출할 때 일어나는 일

<ul>
<li>함수를 호출하면 실행 컨텍스트와 스코프 체인이 생성</li>
<li>(각 함수마다 실행 컨텍스트가 만들어지고 거기에 스코프체인이 연결)</li>
<li>함수의 활성화 객체는 arguments 및 이름 붙은 매개변수로 초기화됨</li>
<li>외부 함수의 활성화 객체는 스코프 체인의 두 번째 객체</li>
<li>이 과정이 포함 관계에 있는 함수에서 계속 발생하여 스코프 체인이 전역 실행 컨텍스트에서 종료될 때까지 이어짐</li>
</ul></li>
<li>함수를 실행하면 값을 읽거나 쓸 변수를 스코프 체인에서 검색

<ul>
<li>전역 컨텍스트의 변수 객체는 항상 존재하지만, 함수 같은 로컬 컨텍스트 변수 객체는 함수를 실행하는 동안에만 존재</li>
<li>스코프 체인이란 변수 객체를 가리키는 포인터 목록이며 객체를 직접 포함하는 것은 아님</li>
<li>함수 실행이 끝나면 로컬 활성화 객체는 파괴되고 메모리에는 전역 스코프만 남음</li>
</ul></li>
<li>하지만 클로저는 다르게 동작

<ul>
<li>그림7-2의 경우, createComparisonFunction의 로컬 활성화 객체가 파괴되지 않고 익명함수의 실행 컨텍스트의 스코프 체인에 추가됨</li>
<li>(다른 함수의 내부에 존재하는 함수는 외부 함수의 활성화 객체를 자신의 스코프 체인에 추가)</li>
<li>따라서 익명 함수의 스코프 체인에는 외부 함수의 활성화 객체를 가리키는 포인터가 존재(그림 7-2의 Scope Chain 2번 포인터)</li>
<li>외부 함수가 실행을 마치고 익명 함수를 반환하면 익명 함수의 스코프 체인은 외부 함수의 활성화 객체와 전역 변수 객체를 포함하도록 초기화됨 -&gt; 익명 함수는 외부 함수의 변수 전체에 접근 가능하게 됨</li>
<li>외부 함수가 실행을 마쳤는데도 활성화 객체가 파괴되지 않음(아직 익명함수의 스코프 체인에서 참조하기 때문)</li>
<li>외부 함수가 실행을 마치면 <code>외부 함수의</code> 실행 컨텍스트의 스코프 체인은 파괴되지만 활성화 객체는 익명 함수가 파괴될 때까지 메모리에 남음</li>
</ul></li>
<li>클로저는 외부 함수의 스코프를 보관해야 하므로 다른 함수에 비해 메모리를 많이 요구하므로 과용하면 메모리 문제가 생길 수 있음! -&gt; 필요한 경우에만 사용하자</li>
</ul>

<h5 id="toc_88">7.2.1 클로저와 변수</h5>

<ul>
<li>스코프 체인에는 한가지 큰 부작용이 존재 - 클로저는 항상 외부 함수의 변수에 마지막으로 저장된 값만 알 수 있음</li>
<li>클로저는 특정 변수가 아니라 전체 변수 객체에 대한 참조를 저장함</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="keyword">Array</span>();

    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++){
        result[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> i;
        };
    }

    <span class="keyword">return</span> result;
}
</code></pre>
<ul>
<li>위에 주어진 예제의 반환값은 함수로 이루어진 배열</li>
<li>보기에는 각 함수가 자신의 인덱스에 해당하는 값을 반환할 것 같지만, 모든 함수가 for문 인덱스의 마지막 값인 10을 반환</li>
<li>모든 함수가 스코프 체인에 로컬 활성화 객체를 포함하므로 이들은 모두 같은 변수 i를 참조함</li>
<li>로컬 함수가 실행을 마치면 i에 10이 저장되므로 모든 함수에서 i값은 10임</li>
<li>다음과 같이 익명 함수를 만들어서 클로저가 적절히 동작하게 만들 수 있음</li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="keyword">Array</span>();

    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++){
        result[i] = <span class="function"><span class="keyword">function</span><span class="params">(num)</span>{</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
                <span class="keyword">return</span> num;
            }
        }(i);
    }

    <span class="keyword">return</span> result;
}
</code></pre>
<ul>
<li>고쳐 쓴 createFunctions()에서는 각 함수가 다른 숫자를 반환</li>
<li>클로저를 직접 배열에 할당하는 대신 익명 함수를 정의하고 즉시 호출</li>
</ul>

<h5 id="toc_89">7.2.2 this 객체</h5>

<ul>
<li>this 객체는 런타임에서 함수가 실행 중인 컨텍스트에 묶임</li>
<li>전역 함수에서는 this는 스트릭트 모드가 아닐 때는 window, 스트릭트 모드에서는 undefined, 함수가 객체 메서드로 호출되었을 때는 해당 객체</li>
<li>클로저 내부의 this 객체는 꽤 복잡하게 동작</li>
<li>클로저를 작성하는 방식 때문에 헷갈릴 수 있음</li>
</ul>
<pre><code class="javascript"><span class="keyword">var</span> name = <span class="string">"The window"</span>;
<span class="keyword">var</span> object = {
    name : <span class="string">"My Obj"</span>,

    getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">return</span> <span class="keyword">this</span>.name;
        };
    }
};

alert(object.getNameFunc()());  <span class="comment">// 결과: The window(스트릭트 모드 아닐 때)</span>
</code></pre>
<ul>
<li>모든 함수는 호출되는 순간 자동으로 this, arguments 객체를 가짐</li>
<li>내부 함수는 결코 외부 함수의 this와 arguments에 직접적으로 접근 불가능함</li>
<li>하지만 클로저 작성 방식 때문에 헷갈릴 수 있음(함수 내부에 있으므로..)</li>
<li>외부 함수의 this객체를 다른 변수에 저장해서 클로저가 이 변수에 접근하도록 하는 일은 가능함</li>
<li>익명 함수를 정의 하기 전에 <code>var that = this;</code> 로 this를 저장하고 익명함수 내부에서 <code>that.name</code>으로 접근</li>
<li><code>that</code>은 외부 함수에 고유한 변수이므로 클로저는 이 변수에 접근 가능함</li>
<li>마찬가지로 외부 스코프의 매개변수 객체에 접근해야 한다면 이에 대한 참조를 다른 변수에 저장하고 접근하면 됨</li>
</ul>

<h5 id="toc_90">7.2.3 메모리 누수</h5>

<ul>
<li>클로저는 인터넷 익스플로러 9 이전 버전에서 메모리 문제를 일으킴</li>
<li>JScript 객체와 COM 객체에 사용하는 가비지 컬렉션 방법이 다르기 때문</li>
<li>익명 함수는 assignHandler() 함수의 활성화 객체에 대한 참조를 계속 유지하는데 이 때문에 element에 대한 참조 카운트가 최소 1에서 더이상 줄어들지 않아서 메모리를 회수할 수 없음</li>
<li>새로 고칠 함수에서는 element의 ID 사본을 클로저에서 사용하는 변수에 저장하여 순환 참조를 막음</li>
<li>하지만 클로저는 외부 함수의 전체 활성화 객체에 대한 참조를 저장하므로 element도 여기에 포함</li>
<li>따라서 필요하다면 element 변수에 null을 할당함</li>
<li>그러면 COM 객체에 대한 참조가 제거되고 참조 카운트도 감소하므로 메모리를 회수할 수 있음</li>
</ul>

<h4 id="toc_91">7.3 블록 스코프 흉내내기</h4>

<ul>
<li>자바스크립트에는 블록 레벨 스코프라는 개념이 없음</li>
<li>블록 문장에서 정의한 변수는 해당 문장이 아니라 외부 함수에 묶임</li>
<li>예를 들어, for loop 내부에서 정의한 변수 i가 같은 함수안에서는 for loop이 끝난 후에도 참조 가능(자바나 C++에서는 불가능)</li>
<li>변수를 재선언(잘못된 것이지만) 해도 값은 그대로 유지됨 - 선언과 동시에 초기화 하는 경우에는 적용됨</li>
<li><p>익명 함수를 통해 블록 스코프를 흉내 내서 이 문제를 해결 가능</p></li>
<li><p>익명함수를 블록 스코프처럼 쓰는 문법 <code>고유 스코프</code>라고 부르고 아래와 같은 형태</p><pre><code class="javascript"><span class="list">(<span class="title">function</span><span class="list">()</span>{
// 코드 블록
})</span><span class="list">()</span><span class="comment">;</span>
</code></pre></li>
<li><p>위의 문법에서는 익명 함수를 정의하는 즉시 호출 - 즉시 호출 함수</p></li>
<li><p>함수 선언처럼 보이는 부분을 괄호(function(){...}) 로 감싸 함수 표현식임을 나타냄</p></li>
<li><p>이 함수는 바로 다음에 나타나는 괄호()를 통해 호출함</p></li>
<li><p>임시 변수가 필요할 때마다 위와 같은 방식으로 고유 스코프를 사용하면 됨</p></li>
<li><p>그러면 고유 스코프 안의 익명 함수에서 정의한 변수는 익명 함수가 실행을 마치는 즉시 파괴됨</p></li>
<li><p>익명 함수는 클로저이기 때문에 외부 변수에 자유로이 접근할 수 있으므로 고유 스코프 만들어도 외부 함수의 변수를 접근가능함</p></li>
<li><p><code>전역 스코프에 추가되는 변수나 함수의 수를 제한하는 용도</code>로 자주 사용함</p></li>
<li><p>일반적으로 전역스코프에 변수나 함수를 추가하지 않는 편이 좋음</p></li>
<li><p>여러 개발자가 참여하는 대규모 애플리케이션에서는 이를 지키면 이름 충돌을 막을 수 있음</p></li>
</ul>

<h4 id="toc_92">7.4 고유 변수</h4>

<ul>
<li>자바스크립트에는 고유 구성원(private member)이란 개념이 없음</li>
<li>객체 프로퍼티는 모두 공용(public)</li>
<li><code>고유 변수</code>라는 개념은 있음 - 예를 들어, 함수 안에서 정의한 변수는 함수 밖에서 접근 불가능하므로 모두 고유 변수라고 간주</li>
<li><code>고유 변수</code>에는 함수 매개변수, 지역 변수, 내부 함수 등이 속함</li>
<li>클로저를 함수 안에서 만들면 스코프 체인을 통해 <code>고유 변수</code>에 접근가능 - 공용 메서드를 만들 수 있음</li>
<li><code>특권(privileged) 메서드</code>는 고유 변수/함수에 접근 가능한 공용 메서드</li>
<li>객체에 특권 메서드를 만드는 방법은 2가지

<ul>
<li>첫 번째, 생성자 안에서 만드는 방법</li>
</ul></li>
</ul>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span>{</span>
    <span class="transposed_variable">this.</span>getName = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> name;
    };
    <span class="transposed_variable">this.</span>setName = <span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
        name = values;
    };
}

var person = new Person(<span class="string">"Luis"</span>);
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person.</span>getName());  <span class="comment">// "Luis"</span>
<span class="transposed_variable">person.</span>setName(<span class="string">"Park"</span>);
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person.</span>getName());  <span class="comment">// "Park"</span>
</code></pre>
<ul>
<li>위와 같이 고유 및 특권 멤버를 정의해서 데이터를 직접적으로 수정할 수 없게 보호 가능</li>
<li>이 코드의 생성자는 getName()과 setName() 두 메서드를 정의하여 생성자 밖에서 각 메서드에 접근하여 고유 변수에 접근 가능하게 함</li>
<li>하지만 생성자 패턴에는 메서드가 인스턴스마다 생성된다는 결점이 있음</li>
<li><code>정적 고유 변수</code>를 사용해 특권 메서드를 만들면 이 결점이 사라짐</li>
</ul>

<h5 id="toc_93">7.4.1 정적 고유 변수</h5>

<ul>
<li>특권 메서드는 고유 변수나 함수를 정의할 때 쓰는 고유 스코프를 통해서 생성할 수도 있음</li>
<li>이 패턴은 생성자와 메서드를 감싸는 고유 스코프를 만들고, 고유 변수와 함수를 정의한 다음 생성자와 공용 메서드를 정의</li>
<li>공용 메서드는 프로토타입엥 정의, 생성자를 함수 표현식을 써서 정의, 생성자는 전역 변수로 만들기 위해 var 키워드를 쓰지 않고 정의함(스트릭트 모드에서는 변수를 선언하지 않고 할당하기만 하면 에러가 나는 것을 주의)</li>
<li>이 패턴과 이전에 나온 패턴과의 주요 차이는 <code>고유 변수와 함수를 인스턴스에서 공유한다</code>는 점</li>
</ul>
<pre><code class="javascript">(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    var name = <span class="string">""</span>;

    Person = <span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
        name = value;
    };
    <span class="transposed_variable">Person.</span><span class="transposed_variable">prototype.</span>getName = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> name;
    };
    <span class="transposed_variable">Person.</span><span class="transposed_variable">prototype.</span>setName = <span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
        name = value;
    };
})();

var person1 = new Person(<span class="string">"Luis"</span>);
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person1.</span>getName()); <span class="comment">// "Luis"</span>
<span class="transposed_variable">person1.</span>setName(<span class="string">"Park"</span>);
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person1.</span>getName()); <span class="comment">// "Park"</span>

var person2 = new Person(<span class="string">"Cheol"</span>);
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person1.</span>getName()); <span class="comment">// "Cheol"</span>
<span class="transposed_variable">console.</span>log(<span class="transposed_variable">person2.</span>getName()); <span class="comment">// "Cheol"</span>

</code></pre>
<ul>
<li>위의 패턴을 보면 name 변수는 정적이 되고 모든 인스턴스에서 공유됨</li>
<li>이런 방식으로 정적 고유 변수를 생성하면 각 인스턴스가 독립 변수를 가질 수는 없지만 프로토타입을 통해 코드 재사용성은 좋아짐</li>
<li>상황에 따라 인스턴스를 쓸 것인지 정적 고유 변수를 쓸 것인지 다르게 결정</li>
</ul>

<h5 id="toc_94">7.4.2 모듈 패턴</h5>

<ul>
<li>더클러스 크록포드가 고안한 모듈 패턴은 싱글톤에서 이전 패턴과 같은 일을 수행</li>
<li>싱글톤이란 인스턴스를 단 하나만 갖게 의도한 객체</li>
<li>전통적으로 자바스크립트에서 싱글톤을 만들 때는 객체 리터럴 표기법을 사용</li>
</ul>
<pre><code class="javascript"><span class="keyword">var</span> singleton = {
    name : value,
    method : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="comment">// 메서드 코드</span>
    }
};
</code></pre>
<ul>
<li>모듈 패턴은 기본 싱글톤을 확장해서 고유 변수와 특권 메서드를 쓸 수 잇음</li>
</ul>
<pre><code class="javascript"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">// 고유 변수와 함수</span>
    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// 특권, 공용 메서드와 프로퍼티</span>
    <span class="keyword">return</span> {
        publicProperty: <span class="literal">true</span>,

        publicMethod : <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            privateVariable++;
            <span class="keyword">return</span> privateFunction();
        }
    };
}();
</code></pre>
<ul>
<li>모듈 패턴은 객체를 반호한하는 익명 함수를 사용</li>
<li>객체는 익명 함수 내에 정의되었으므로 공용 메서드는 모두 고유 변수와 함수에 접근 가능</li>
<li>객체 리터럴이 싱글톤에 대한 공용 인터페이스를 정의하는 것</li>
<li>이 패턴은 싱글톤에 일종의 초기화가 필요하고 고유 변수에 접근해야 할 때 유용</li>
<li>모듈 패턴은 단 하나의 객체를 반드시 생성하고 몇 가지 데이터를 가지며 또한 고유 데이터에 접근 가능한 공용 메서드를 외부에 노출하도록 초기화 해야 할 때 유용</li>
</ul>

<h5 id="toc_95">7.4.3 모듈 확장 패턴</h5>

<ul>
<li>객체를 반환하기 전에 확장하는 패턴</li>
<li>이 패턴은 싱글톤 객체가 특정 타입의 인스턴스지만 프로퍼티나 메서드를 추가하여 확장해야 할 때 유용</li>
<li>이전 예제에서는 객체를 그냥 바로 return하나, 이 패턴에서는 객체를 생성하여 그 객체에 특권/공용 프로퍼티와 메서드를 추가하고.. 그 객체를 반환</li>
</ul>

                        </div>

                        <hr />
                        
                                            
                        <div class="meta clearfix">
                            

                            
                            <div class="pull-left prev-next">
                                <a href="/post/javascript-study5-reference-type" class="button prev"><i class="icon"></i> 자바스크립트 제대로 배우기 - 5.참조 타입</a>
                            </div>
                            
                        </div>
                    

                        
    <div class="row-fluid">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'luispark'; // required: replace example with your forum shortname

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

                    </div>
                </div>
            </div>
            <div class="row">
            </div>
        </div>
    </div>
    <!--<div class="row">-->
        <!--<div class="offset3 span9">-->
            <!--<strong>tags</strong> :-->
            <!---->
        <!--</div>-->
    <!--</div>-->
</div><!-- /container -->


        <footer class="footer">
        <div class="container">
            <div class="row">
                <div class="span9 offset3">
                    <div class="well">
                        <p class="pull-right"><a href="#" class="backtotop">Back to top</a></p>
                            <strong>haroopress</strong> developed by <a href="http://twitter.com/rhiokim" target="_blank">@rhiokim</a>,<a href="http://twitter.com/haroopress" target="_blank">@haroopress</a> and source in <a href="https://github.com/rhiokim/haroopress" target="_blank">github</a><br/>
                            Designed and built with all the love in the world <a href="http://twitter.com/twitter" target="_blank">@twitter</a> by <a href="http://twitter.com/mdo" target="_blank">@mdo</a> and <a href="http://twitter.com/fat" target="_blank">@fat</a>.<br />
                            Code licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
                    </div>
                </div>
            </div>
        </div>
    </footer>

    
    <script type="text/javascript">
        var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-34861484-1']);
            _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>



</body>
</html>
